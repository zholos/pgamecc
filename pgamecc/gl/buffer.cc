#include "buffer.h"

#include <stdexcept>

using std::unique_ptr;
using std::logic_error;
using std::runtime_error;

using namespace pgamecc::gl;


//
// gl::Array and gl::UniformBuffer
//

// tests related to converting between arrays of vec and GLfloat
static_assert(
    sizeof(glm::vec2) == sizeof(GLfloat) * 2 &&
    sizeof(glm::vec3) == sizeof(GLfloat) * 3 &&
    sizeof(glm::vec4) == sizeof(GLfloat) * 4,
    "unexpected padding in vec");
static_assert(
    sizeof(glm::ivec2) == sizeof(GLint) * 2 &&
    sizeof(glm::ivec3) == sizeof(GLint) * 3 &&
    sizeof(glm::ivec4) == sizeof(GLint) * 4,
    "unexpected padding in ivec");
static_assert(
    alignof(glm::vec2) == alignof(GLfloat) &&
    alignof(glm::vec3) == alignof(GLfloat) &&
    alignof(glm::vec4) == alignof(GLfloat),
    "unexpected alignment of vec");
static_assert(
    alignof(glm::ivec2) == alignof(GLint) &&
    alignof(glm::ivec3) == alignof(GLint) &&
    alignof(glm::ivec4) == alignof(GLint),
    "unexpected alignment of ivec");


detail::GenericBuffer::GenericBuffer()
{
    error_check ec("Buffer constructor");
    glGenBuffers(1, &object);
}

namespace pgamecc { namespace gl { namespace detail {
template<> void
Object<GenericBuffer>::destroy()
{
    error_check ec("Buffer destructor");
    glDeleteBuffers(1, &object);
}
}}}


static GLuint
current_buffer_binding(GLenum target) {
    GLint buffer = 0;
    switch (target) {
    case GL_ARRAY_BUFFER:
        glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &buffer); break;
    case GL_UNIFORM_BUFFER:
        glGetIntegerv(GL_UNIFORM_BUFFER_BINDING, &buffer); break;
    }
    return buffer;
}

void
detail::GenericBuffer::bind_target(GLenum target) const
{
#ifndef NDEBUG
    if (current_buffer_binding(target))
        throw logic_error("binding buffer while binding in use");
#endif
    glBindBuffer(target, object);
}


void
detail::GenericBuffer::unbind_target(GLenum target)
{
    glBindBuffer(target, 0);
}

void
detail::GenericBuffer::load_void(GLenum target, GLenum usage,
                                 const void* data, size_t size)
{
    error_check ec("Buffer::load()");
    bind_target(target);
    glBufferData(target, size, data, usage);
    unbind_target(target);
}

unique_ptr<void, detail::GenericBuffer::map_deleter>
detail::GenericBuffer::map_void(GLenum target, GLenum usage,
                                size_t size, GLenum access)
{
    error_check ec("Buffer::map()");
    bind_target(target);
    glBufferData(target, size, nullptr, usage);
    void* map = glMapBuffer(target, access);
    unbind_target(target);
    return { map, { *this, target } };
}

void
detail::GenericBuffer::map_deleter::operator()(void*)
{
    buffer.bind_target(target);
    if (!glUnmapBuffer(target))
        throw runtime_error("unhandled buffer invalidation");
    buffer.unbind_target(target);
}

void
detail::GenericBuffer::clear_bytes(GLenum target, GLenum usage, size_t size)
{
    error_check ec("Buffer::clear_bytes()");
    bind_target(target);
    glBufferData(target, size, nullptr, usage);
    unbind_target(target);
}

size_t
detail::GenericBuffer::size_bytes(GLenum target) const
{
    error_check ec("Buffer::size()");
    bind_target(target);
    GLint size;
    glGetBufferParameteriv(target, GL_BUFFER_SIZE, &size);
    unbind_target(target);
    return size;
}


void
detail::GenericBuffer::bind_vertex(GLuint binding, size_t offset, size_t stride)
{
    error_check ec("Array::bind()");
    glBindVertexBuffer(binding, object, offset, stride);
}

void
detail::GenericBuffer::bind_uniform(GLenum target,
                                    GLuint binding, size_t size, size_t offset)
{
    error_check ec("UniformBuffer::bind()");
    glBindBufferRange(target, binding, object, offset, size);
    unbind_target(target); // glBindBufferRange also binds to generic target
}


const glm::vec4 pgamecc::gl::quad_strip[] = {
    glm::vec4{0, 0, 0, 1},
    glm::vec4{1, 0, 0, 1},
    glm::vec4{0, 1, 0, 1},
    glm::vec4{1, 1, 0, 1}
};

// generated by misc/cube.c
const glm::vec4 pgamecc::gl::cube_strip[] = {
    glm::vec4{0, 0, 0, 1},
    glm::vec4{1, 0, 0, 1},
    glm::vec4{0, 0, 1, 1},
    glm::vec4{1, 0, 1, 1},
    glm::vec4{1, 1, 1, 1},
    glm::vec4{1, 0, 0, 1},
    glm::vec4{1, 1, 0, 1},
    glm::vec4{0, 1, 0, 1},
    glm::vec4{1, 1, 1, 1},
    glm::vec4{0, 1, 1, 1},
    glm::vec4{0, 0, 1, 1},
    glm::vec4{0, 1, 0, 1},
    glm::vec4{0, 0, 0, 1},
    glm::vec4{1, 0, 0, 1}
};
